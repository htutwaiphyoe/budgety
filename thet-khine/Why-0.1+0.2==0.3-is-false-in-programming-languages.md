# Why 0.1+0.2==0.3 is false in programming languages

အပေါ်က expression 0.1+0.2==0.3 ကို programming languages တိုင်းလိုလိုမှာ စမ်းကြည့်လိုက်ရင် true return မပြန်ပဲနဲ. false ဆိုပြီး return ပြန်တယ်ပေါ့။

0.1+0.2 ပေါင်းတာက 0.3 မဟုတ်ဘူးလားဆိုရင်ဖြင့် computer မှာတော့မဟုတ်ဘူးရယ်လိုဆိုရမယ်။ တိတိကျကျပြောရရင်တော့ IEEE floating point representation ကိုသုံးတဲ့ language တွေ computer application တွေမှာမဟုတ်ဘူးလို.ဆိုရမယ်။ တခြား floating point representation ကိုသုံးတဲ့ Big Decimal လိုကောင်မျိုးမှာဆိုရင်တော့ 0.3 ရမယ်ပေါ့။

ဒါဆို ဘာလို. အဲ့လိုဖြစ်ရသလဲပေ့ါ။ ကွန်ပျူတာတွေမှာ floating point ကို represent လုပ်တဲ့အခါ အတိအကျမလုပ်နိုင်ဘူး အနီးစပ်ဆုံးတူရာကိုသာလုပ်လို.ရတယ်။ အဲ့တော့ error အနည်းနိုင်ဆုံး format ကိုသုံးတယ်။ အရမ်းကြီး မူလတန်ဖိုးနဲ.သိပ်မကွာနိုင်တာမျိုးပေါ့။ ဘာကြောင့် ကွန်ပျူတာ ဒဿမကိန်းတွေကို အတိအကျမလုပ်နိုင်ဘူးဆိုရင် အဖြေက ဥပမာ PI တန်ဖိုးဆိုပါစို. သူ.ကို represent လုပ်ရင် 22/7 ပေါ့ အဲ့တာဆို ဘယ်တော့မှ မပြတ်ဘူး အဲ့တော့ သူ.နောက်က ဒဿမကိန်း တန်ဖိုးတွေကိုသိမ်းဖို.ဆိုရင် ကွန်ပျူတာ တခုလုံးပြည့်လဲ မလောက်သေးဘူး။ ဒါကြောင့်လက်တွေ.သိမ်းလို.လဲအဆင်ပြေအောင် ဆိုပြီး နီးစပ်တဲ့တန်ဖိုး တိကျတဲ့တန်ဖိုးမဟုတ်ဘူးပေါ့ အဲ့ကောင်ကိုသိမ်းရတယ်။

ဒါဆို ဘယ်လိုသိမ်းလဲပေ့ါ။ Programming langauge အများဆုံးက IEEE 754 format ဆိုတာကိုသုံးတယ်။Floating point representation ပေ့ါ။ ဘာလို. floating point လို.ခေါ်သလဲဆိုရင် point နေရာလေးက ရွှေ.လို.ရလို. float လုပ်လို.ရတယ်။ ဒါကြောင့် floating point လို.ခေါ်တာ.။ ရွှေ.လို.ရတယ်ဆိုတာ ဥပမာ 2.3 ဆိုပါစို. သူ.ကို 2.3*10(1) လို.လဲရေးလို.ရတယ်။ အဲ့တော့ခုနက ပွိုင့်နေရာလေးသည် ပြောင်းရေးလို.ရတယ်လို.ဆိုချင်တာ။ အဲ့လိုရေးနည်းကို scientific notation လို.လဲဆိုကြတယ်။

Computer မှာသုံးတဲ့ IEEE 754 format သည်ခုနက scientific notation ကိုအခြေခံပြီးသုံးပြီးထုတ်ထားတာ။ ဘယ်လို သိမ်းလဲဆိုရင် ဒီလိုသုံးတယ်။

Sign, Exponent , Mantissa

အဲ့လို ၃ ပိုင်းကို binary နဲ.ခွဲသိမ်းတာ Sign သည်သာမာန်အားဖြင့် 1 bit ပဲ။ 1 ဆို negative 0 ဆိုရင် positive, ပဲ exponent ကျတော့ 32 bit IEEE 754 ဆိုရင် exponent သည် 8 bit ကိုသုံးတယ်။ 8 bit မှာ exponent ကို အပေါင်းရော အနှုတ်ပါ တွဲသိမ်းတယ် ဆိုချင်တော့ 1 bit က sign အတွက်ထားရတော့ +127 - 128 အဲ့လောက်ကိုသိမ်းလို.ရတယ်။ နောက်က Mantissa ဆိုတာ ဒဿမကိန်းနောက်က ကောင်တွေ့သိမ်းတာ။ Mantissa ကိုမသိမ်းခင် scientific notation ကိုအရင်ပြောင်းရသေးတယ်။

ဥပမာ2.625 ကို floating point အနေနဲ. represent လုပ်မယ်ဆိုရင် integer အပိုင်းက ၂ ဒါဆို binary အနေနဲ. 10
နောက် ဒဿမ အပိုင်းကိုကျတော့ .625 သူ.ကို binary နဲ. represent လုပ်မယ်ဆိုရင် 2 နဲ.မြှောက်ရတယ်။

0.625 × 2 = 1.25=>1 (ဘယ်ဘက်က ကောင်ကိုယူရင် 1 )
0.25 × 2 = 0.5=>0
0.5 × 2 = 1.0=>1
နောက်ဆုံး ကုန်သွားတော့ ရပ်လိုက်ပြီ ဒါဆို ဒီလိုရမယ်။

0.625(base 10) = 0.101(base 2), and 2.625(base 10) = 10.101(base 2) ရမယ်။

ခုနက fraction အပိုင်းကို exponent ထဲ့ နောက် scientific notation ကိုပြောင်း ( ဒဿမကိန်းတွေကိုရွေ.ပြစ်တာ အဲ့လိုနည်းနဲ. ) ၃ ပိုင်း represent လုပ်လို.ရတယ်သွားတယ်။
ဒါဆို ခုနက 0.1 ရဲ. ပြဿနာက ဘာလဲဆိုတော့ decimal ဆိုရင် ရှင်းတယ်။1/10 ပေါ့။ binary ဆိုရင် base 2 နဲ. represent လုပ်ရမယ်။

အဲ့တော့ 0.1 ကို binary ပိုင်းပြောင်းမယ်ဆိုရင် (တကယ်က fraction ဘက်ကိုလုပ်တာ ဥပမာ 2.1 ဆိုလဲ fraction ဘက် 0.1 ကိုပဲယူရမယ် integral ဘက်က သက်သက် လုပ်တယ်။)

0.1 x 2 = 0.2 => 0
0.2 x 2 = 0.4 => 0
0.4 x 2 = 0.8=>. 0
0.8 x 2 =>1.6=> 1
0.6 x 2 => 1.2=> 1
0.2 x 2 = 0.4 => 0
0.4 x 2 = 0.8=>. 0
0.8 x 2 =>1.6=> 1

အဲ့တော့ မဆုံးတော့ဘူး 001100011------- ဆိုပြီးပတ်နေမှာ
အဲ့တော့ bit ဆန်.သလောက်နဲ. ရပ်လိုက်ရမယ် အဲ့မှာတင် 0.1 ကိုနည်းနည်းလျော့သွားမယ် ဒါကြောင့် 0.2 နဲ.ပေါင်းလိုက်တော့ 0.3 မဟုတ်တော့ဘူး။

Programming ကလွယ်လားမေးရင် arithmetic တောင်သေချာသိဖို. CS နားမလည်ပဲ မသိနိုင်ဘူး

Original: [https://www.facebook.com/thet.khine.587/posts/pfbid0Rn3ReCuZQX21WNfSxRKbK8shG6pjMEuF2f4NVbaGRE3yrfwKcgzVYLTVh44mQ8LYl](https://www.facebook.com/thet.khine.587/posts/pfbid0Rn3ReCuZQX21WNfSxRKbK8shG6pjMEuF2f4NVbaGRE3yrfwKcgzVYLTVh44mQ8LYl)
